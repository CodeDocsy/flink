ä½ é‡åˆ°çš„è¿™ä¸ªå¼‚å¸¸ï¼š

```
Exception in thread "main" org.apache.flink.api.common.functions.InvalidTypesException: 
The return type of function 'main(StreamWordCountWindowJob.java:56)' could not be determined automatically, due to type erasure.
...
Caused by: The generic type parameters of 'Collector' are missing.
```

æ˜¯ **Flink å¸¸è§çš„ç±»å‹æ¨æ–­å¤±è´¥é—®é¢˜**ï¼Œå°¤å…¶æ˜¯åœ¨ä½¿ç”¨ **Lambda è¡¨è¾¾å¼ + æ³›å‹** æ—¶ï¼ŒJava çš„ç±»å‹æ“¦é™¤å¯¼è‡´ Flink æ— æ³•çŸ¥é“ä½ çš„ `flatMap` è¾“å‡ºçš„æ˜¯ä»€ä¹ˆç±»å‹ã€‚

---

## ğŸ” é”™è¯¯åŸå› 

ä½ å¯èƒ½å†™äº†ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š

```java
.flatMap((line, out) -> {
    for (String word : line.split("\\s+")) {
        out.collect(word);
    }
})
```

æˆ–è€…ï¼š

```java
.flatMap((String line, Collector<String> out) -> { ... })
```

è™½ç„¶ä½ æŒ‡å®šäº† `Collector<String>`ï¼Œä½† **Java Lambda çš„ç±»å‹æ¨å¯¼æœºåˆ¶åœ¨æ³›å‹+å‡½æ•°æ¥å£ä¸­ä¸å¤Ÿå¼º**ï¼ŒFlink æ— æ³•ä» Lambda ä¸­è‡ªåŠ¨æå–å‡ºè¿”å›ç±»å‹ï¼ˆå³è¾“å‡ºæµçš„ç±»å‹ï¼‰ï¼Œäºæ˜¯æŠ¥é”™ï¼š

> âŒ `The generic type parameters of 'Collector' are missing`

---

## âœ… è§£å†³æ–¹æ¡ˆï¼ˆ3ç§ï¼‰

### âœ… æ–¹æ³•ä¸€ï¼šä½¿ç”¨ `.returns(...)` æ˜¾å¼æŒ‡å®šè¿”å›ç±»å‹ï¼ˆæ¨èï¼Œç®€æ´ï¼‰

```java
import org.apache.flink.api.common.typeinfo.Types;

.flatMap((String line, Collector<String> out) -> {
    for (String word : line.split("\\s+")) {
        if (!word.isEmpty()) {
            out.collect(word);
        }
    }
})
.returns(Types.STRING)  // âœ… æ˜¾å¼å‘Šè¯‰ Flinkï¼šè¾“å‡ºæ˜¯ String ç±»å‹
```

ğŸ“Œ è¿™æ˜¯æœ€ç®€å•ã€æœ€ç›´æ¥çš„ä¿®å¤æ–¹å¼ã€‚

---

### âœ… æ–¹æ³•äºŒï¼šæ”¹ç”¨åŒ¿åå†…éƒ¨ç±»ï¼ˆæ›´å…¼å®¹ï¼Œé€‚åˆè€ç‰ˆæœ¬ï¼‰

```java
.flatMap(new FlatMapFunction<String, String>() {
    @Override
    public void flatMap(String line, Collector<String> out) {
        for (String word : line.split("\\s+")) {
            if (!word.isEmpty()) {
                out.collect(word);
            }
        }
    }
})
```

åŒ¿åå†…éƒ¨ç±»å¸¦æœ‰å®Œæ•´çš„æ³›å‹ä¿¡æ¯ï¼ŒFlink èƒ½æ­£ç¡®æ¨æ–­ç±»å‹ï¼Œ**ä¸ä¼šæŠ¥é”™**ã€‚

---

### âœ… æ–¹æ³•ä¸‰ï¼šè®©å‡½æ•°ç±»å®ç° `ResultTypeQueryable`ï¼ˆé«˜çº§ï¼Œä¸€èˆ¬ä¸ç”¨ï¼‰

é€‚ç”¨äºè‡ªå®šä¹‰å‡½æ•°ç±»ï¼š

```java
public static class MyFlatMap implements FlatMapFunction<String, String>, ResultTypeQueryable<String> {
    @Override
    public void flatMap(String line, Collector<String> out) {
        for (String word : line.split("\\s+")) {
            out.collect(word);
        }
    }

    @Override
    public TypeInformation<String> getProducedType() {
        return Types.STRING;
    }
}
```

ç„¶åä½¿ç”¨ï¼š

```java
.flatMap(new MyFlatMap())
```

---

## ğŸ› ï¸ å®Œæ•´ä¿®å¤ç¤ºä¾‹ï¼ˆä½¿ç”¨ `.returns()`ï¼‰

```java
import org.apache.flink.api.common.typeinfo.Types;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.util.Collector;

public class StreamWordCountWindowJob {

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStreamSource<String> socketTextStream = env.socketTextStream("localhost", 9999);

        socketTextStream
                // ä½¿ç”¨ Lambdaï¼Œä½†æ˜¾å¼æŒ‡å®šè¿”å›ç±»å‹
                .flatMap((String line, Collector<String> out) -> {
                    for (String word : line.trim().split("\\s+")) {
                        if (!word.isEmpty()) {
                            out.collect(word);
                        }
                    }
                })
                .returns(Types.STRING)  // âœ… å…³é”®ï¼šå‘Šè¯‰ Flink è¾“å‡ºç±»å‹
                .map(word -> new CountItem(word, 1))
                .keyBy(CountItem::getKey)
                .window(TumblingProcessingTimeWindows.of(Time.seconds(10)))
                .reduce((a, b) -> new CountItem(a.getKey(), a.getCount() + b.getCount()))
                .print();

        env.execute("Fixed Word Count");
    }
}
```

---

## âœ… è¡¥å……ï¼šå¸¸ç”¨ `Types` ç±»å‹

```java
Types.STRING
Types.INT
Types.LONG
Types.BOOLEAN
Types.DOUBLE

// POJO ç±»å‹ï¼ˆéœ€ç¬¦åˆ POJO è§„èŒƒï¼‰
Types.POJO(CountItem.class)

// Tuple
Types.TUPLE(Types.STRING, Types.INT)
```

---

## âœ… æ€»ç»“

| æ–¹æ³• | é€‚ç”¨åœºæ™¯ | æ¨èåº¦ |
|------|----------|--------|
| `.returns(Types.STRING)` | Lambda è¡¨è¾¾å¼ | â­â­â­â­â˜†ï¼ˆæœ€ç®€å•ï¼‰ |
| åŒ¿åå†…éƒ¨ç±» | å…¼å®¹æ€§è¦æ±‚é«˜ | â­â­â­â­ |
| `ResultTypeQueryable` | è‡ªå®šä¹‰å¤æ‚å‡½æ•° | â­â­ |

---

### ğŸ”š æœ€ç»ˆå»ºè®®

âœ… **ä¼˜å…ˆä½¿ç”¨ `.returns()`** æ¥ä¿®å¤ç±»å‹æ¨æ–­é—®é¢˜ï¼Œä»£ç ç®€æ´ä¸”ç°ä»£ã€‚

åªè¦ä½ åœ¨ä½¿ç”¨ Lambda åš `flatMap`ã€`map` ç­‰æ“ä½œæ—¶é‡åˆ°ç±»å‹æ“¦é™¤é—®é¢˜ï¼ŒåŠ ä¸€è¡Œ `.returns(...)` å°±èƒ½è§£å†³ã€‚

---

å¦‚æœä½ è¿˜æœ‰å…¶ä»–ç®—å­ï¼ˆå¦‚ `map`ï¼‰æŠ¥ç±»ä¼¼é”™è¯¯ï¼Œä¹Ÿå¯ä»¥åŒæ ·å¤„ç†ï¼š

```java
.map(word -> new CountItem(word, 1))
.returns(Types.POJO(CountItem.class))  // å¦‚æœæ˜¯ POJO
```